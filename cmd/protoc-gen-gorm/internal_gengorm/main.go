package internal_gengorm

import (
	"flag"
	"fmt"

	"github.com/complex64/protoc-gen-gorm/gormpb/v2"
	"github.com/complex64/protoc-gen-gorm/internal/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	// Use extension .pb.go, just like `protoc-gen-go` does.
	extension = "_gorm.pb.go"
)

func GenerateFile(fs flag.FlagSet, plugin *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	filename := file.GeneratedFilenamePrefix + extension

	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	f, err := newFileInfo(file)
	if err != nil {
		return nil, err
	}

	genHeader(plugin, g, f)
	g.P("package ", file.GoPackageName)
	g.P()

	for i, imps := 0, f.Desc.Imports(); i < imps.Len(); i++ {
		genImport(plugin, g, f, imps.Get(i))
	}

	for _, message := range f.allMessages {
		genModels(g, f, message)
	}

	return g, nil
}

// genHeader generates the comment header at the top of the file.
// We warn to not edit the file and show the tool versions used to generate the file.
func genHeader(plugin *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo) {
	g.P("// Code generated by protoc-gen-gorm. DO NOT EDIT.")
	g.P("// versions:")

	protocGenGormVersion := version.String()
	protocVersion := "(unknown)"

	if v := plugin.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf(
			"v%v.%v.%v",
			v.GetMajor(),
			v.GetMinor(),
			v.GetPatch(),
		)
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}

	g.P("// \tprotoc-gen-gorm ", protocGenGormVersion)
	g.P("// \tprotoc          ", protocVersion)

	if f.Proto.GetOptions().GetDeprecated() {
		g.P("// ", f.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", f.Desc.Path())
	}

	g.P()
}

func genImport(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, imp protoreflect.FileImport) {
	if imp.IsPublic {
		panic("TODO: Support for public imports")
	}

	impFile, ok := gen.FilesByPath[imp.Path()]
	if !ok {
		return // .proto file unavailable.
	}

	if impFile.GoImportPath == f.GoImportPath {
		return // Same Go package.
	}

	g.Import(impFile.GoImportPath)
	g.P()
}

// fileInfo wraps and organizes the input .proto file to generate code.
type fileInfo struct {
	*protogen.File

	allMessages []*messageInfo

	genModel    bool
	genHooks    bool
	genValidate bool
	genCRUD     bool
}

func newFileInfo(file *protogen.File) (*fileInfo, error) {
	f := &fileInfo{File: file}

	if opts := fileOptions(file); opts != nil {
		implyModel := opts.Hooks || opts.Validate || opts.Crud
		f.genModel = opts.Model || implyModel
	}

	// TODO
	// Collect all enums, messages, and extensions in "flattened ordering".
	// See filetype.TypeBuilder.
	var walkMessages func([]*protogen.Message, func(*protogen.Message) error) error

	walkMessages = func(messages []*protogen.Message, f func(*protogen.Message) error) error {
		for _, m := range messages {
			if err := f(m); err != nil {
				return err
			}
			if err := walkMessages(m.Messages, f); err != nil {
				return err
			}
		}
		return nil
	}

	//	initEnumInfos := func(enums []*protogen.Enum) {
	//		for _, enum := range enums {
	//			f.allEnums = append(f.allEnums, newEnumInfo(f, enum))
	//		}
	//	}

	initMessageInfos := func(messages []*protogen.Message) error {
		for _, message := range messages {
			m, err := newMessageInfo(f, message)
			if err != nil {
				return err
			}
			f.allMessages = append(f.allMessages, m)
		}
		return nil
	}

	//	initExtensionInfos := func(extensions []*protogen.Extension) {
	//		for _, extension := range extensions {
	//			f.allExtensions = append(f.allExtensions, newExtensionInfo(f, extension))
	//		}
	//	}
	//	initEnumInfos(f.Enums)
	//	initMessageInfos(f.Messages)
	//	initExtensionInfos(f.Extensions)

	if err := initMessageInfos(f.Messages); err != nil {
		return nil, err
	}

	err := walkMessages(f.Messages, func(m *protogen.Message) error {
		// initEnumInfos(m.Enums)
		if err := initMessageInfos(m.Messages); err != nil {
			return err
		}
		// initExtensionInfos(m.Extensions)
		return nil
	})
	if err != nil {
		return nil, err
	}

	//
	//	// Derive a reverse mapping of enum and message pointers to their index
	//	// in allEnums and allMessages.
	//	if len(f.allEnums) > 0 {
	//		f.allEnumsByPtr = make(map[*enumInfo]int)
	//		for i, e := range f.allEnums {
	//			f.allEnumsByPtr[e] = i
	//		}
	//	}
	//	if len(f.allMessages) > 0 {
	//		f.allMessagesByPtr = make(map[*messageInfo]int)
	//		f.allMessageFieldsByPtr = make(map[*messageInfo]*structFields)
	//		for i, m := range f.allMessages {
	//			f.allMessagesByPtr[m] = i
	//			f.allMessageFieldsByPtr[m] = new(structFields)
	//		}
	//	}
	//
	//	return f

	return f, nil
}

func fileOptions(file *protogen.File) *gormpb.FileOptions {
	opts := file.Desc.Options()
	o, ok := proto.GetExtension(opts, gormpb.E_File).(*gormpb.FileOptions)
	if !ok || o == nil {
		return nil
	}
	return o
}

type messageInfo struct {
	*protogen.Message

	genModel    bool
	genHooks    bool
	genValidate bool
	genCRUD     bool
}

func newMessageInfo(f *fileInfo, message *protogen.Message) (*messageInfo, error) {
	m := &messageInfo{Message: message}

	m.genModel = f.genModel
	m.genHooks = f.genHooks
	m.genValidate = f.genValidate
	m.genCRUD = f.genCRUD

	if opts := messageOptions(message); opts != nil {
		m.genModel = m.genModel || opts.Model || opts.Hooks || opts.Validate || opts.Crud
		m.genHooks = m.genHooks || opts.Hooks
		m.genValidate = m.genValidate || opts.Validate
		m.genCRUD = m.genCRUD || opts.Crud
	}

	return m, nil
}

func messageOptions(message *protogen.Message) *gormpb.MessageOptions {
	opts := message.Desc.Options()
	o, ok := proto.GetExtension(opts, gormpb.E_Message).(*gormpb.MessageOptions)
	if !ok || o == nil {
		return nil
	}
	return o
}

func genModels(g *protogen.GeneratedFile, f *fileInfo, m *messageInfo) {
	if !m.genModel {
		return
	}

	name := m.GoIdent.GoName
	modelName := fmt.Sprintf("%sModel", name)

	// Message type declaration.
	g.Annotate(name, m.Location)

	leading := protogen.Comments(fmt.Sprintf(
		" %s is the GORM model for %s.%s.",
		modelName, f.GoPackageName,
		name,
	))
	leadingComments := appendDeprecationSuffix(
		leading,
		m.Desc.Options().(*descriptorpb.MessageOptions).GetDeprecated(),
	)

	g.P(leadingComments,
		"type ", modelName, " struct {")
	// genMessageFields(g, f, m)
	g.P("}")
	g.P()

	//
	// genMessageKnownFunctions(g, f, m)
	// genMessageDefaultDecls(g, f, m)
	// genMessageMethods(g, f, m)
	// genMessageOneofWrapperTypes(g, f, m)
}

// TODO
// appendDeprecationSuffix optionally appends a deprecation notice as a suffix.
func appendDeprecationSuffix(prefix protogen.Comments, deprecated bool) protogen.Comments {
	if !deprecated {
		return prefix
	}
	if prefix != "" {
		prefix += "\n"
	}
	return prefix + " Deprecated: Do not use.\n"
}
