package internal_gengorm

import (
	"flag"
	"fmt"

	"github.com/complex64/protoc-gen-gorm/gormpb/v2"
	"github.com/complex64/protoc-gen-gorm/internal/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	// Use extension .pb.go, just like `protoc-gen-go` does.
	extension = "_gorm.pb.go"
)

func GenerateFile(fs flag.FlagSet, plugin *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	filename := file.GeneratedFilenamePrefix + extension

	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	f, err := newFileInfo(file)
	if err != nil {
		return nil, err
	}

	genHeader(plugin, g, f)
	g.P("package ", file.GoPackageName)
	g.P()

	for i, imps := 0, f.Desc.Imports(); i < imps.Len(); i++ {
		genImport(plugin, g, f, imps.Get(i))
	}

	for _, message := range f.allMessages {
		genModels(g, f, message)
	}

	return g, nil
}

// genHeader generates the comment header at the top of the file.
// We warn to not edit the file and show the tool versions used to generate the file.
func genHeader(plugin *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo) {
	g.P("// Code generated by protoc-gen-gorm. DO NOT EDIT.")
	g.P("// versions:")

	protocGenGormVersion := version.String()
	protocVersion := "(unknown)"

	if v := plugin.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf(
			"v%v.%v.%v",
			v.GetMajor(),
			v.GetMinor(),
			v.GetPatch(),
		)
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}

	g.P("// \tprotoc-gen-gorm ", protocGenGormVersion)
	g.P("// \tprotoc          ", protocVersion)

	if f.Proto.GetOptions().GetDeprecated() {
		g.P("// ", f.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", f.Desc.Path())
	}

	g.P()
}

// genImport adds necessary import statements to the generated file.
func genImport(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, imp protoreflect.FileImport) {
	if imp.IsPublic {
		panic("TODO: Implement support for public imports")
	}

	impFile, ok := gen.FilesByPath[imp.Path()]
	if !ok {
		return // .proto file unavailable.
	}

	if impFile.GoImportPath == f.GoImportPath {
		return // Same Go package.
	}

	g.Import(impFile.GoImportPath)
	g.P()
}

// fileInfo wraps the input .proto file and keeps information to generate code.
type fileInfo struct {
	*protogen.File

	allMessages []*messageInfo

	genModel    bool
	genHooks    bool
	genValidate bool
	genCRUD     bool
}

func newFileInfo(file *protogen.File) (*fileInfo, error) {
	f := &fileInfo{File: file}

	if opts := fileOptions(file); opts != nil {
		implyModel := opts.Hooks || opts.Validate || opts.Crud
		f.genModel = opts.Model || implyModel
	}

	// Collect all messages recursively.
	var walkMessages func([]*protogen.Message, func(*protogen.Message) error) error
	walkMessages = func(messages []*protogen.Message, f func(*protogen.Message) error) error {
		for _, m := range messages {
			if err := f(m); err != nil {
				return err
			}
			if err := walkMessages(m.Messages, f); err != nil {
				return err
			}
		}
		return nil
	}

	initMessageInfos := func(messages []*protogen.Message) error {
		for _, message := range messages {
			m, err := newMessageInfo(f, message)
			if err != nil {
				return err
			}
			f.allMessages = append(f.allMessages, m)
		}
		return nil
	}

	if err := initMessageInfos(f.Messages); err != nil {
		return nil, err
	}

	err := walkMessages(f.Messages, func(m *protogen.Message) error {
		if err := initMessageInfos(m.Messages); err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	return f, nil
}

// fileOptions returns the protoc-gen-gorm options for file.
// Example: option (gorm.v2.file).model = true;
func fileOptions(file *protogen.File) *gormpb.FileOptions {
	opts := file.Desc.Options()
	o, ok := proto.GetExtension(opts, gormpb.E_File).(*gormpb.FileOptions)
	if !ok || o == nil {
		return nil
	}
	return o
}

// messageInfo wraps a message from the input .proto file and keeps information to generate code.
type messageInfo struct {
	*protogen.Message

	genModel    bool
	genHooks    bool
	genValidate bool
	genCRUD     bool
}

func newMessageInfo(f *fileInfo, message *protogen.Message) (*messageInfo, error) {
	m := &messageInfo{Message: message}

	// File flags override message flags.
	m.genModel = f.genModel
	m.genHooks = f.genHooks
	m.genValidate = f.genValidate
	m.genCRUD = f.genCRUD

	if opts := messageOptions(message); opts != nil {
		// Generate a model when using features that need the model.
		m.genModel = m.genModel || opts.Model || opts.Hooks || opts.Validate || opts.Crud
		m.genHooks = m.genHooks || opts.Hooks
		m.genValidate = m.genValidate || opts.Validate
		m.genCRUD = m.genCRUD || opts.Crud
	}

	return m, nil
}

// messageOptions returns the protoc-gen-gorm options set for message.
// Example: message MyMessage { option (gorm.v2.message).model = true; }
func messageOptions(message *protogen.Message) *gormpb.MessageOptions {
	opts := message.Desc.Options()
	o, ok := proto.GetExtension(opts, gormpb.E_Message).(*gormpb.MessageOptions)
	if !ok || o == nil {
		return nil
	}
	return o
}

// genModels generates GORM models and supporting APIs.
func genModels(g *protogen.GeneratedFile, f *fileInfo, m *messageInfo) {
	if !m.genModel {
		return
	}

	name := m.GoIdent.GoName
	modelName := fmt.Sprintf("%sModel", name)

	// Message type declaration.
	g.Annotate(name, m.Location)

	leading := protogen.Comments(fmt.Sprintf(
		" %s is the GORM model for %s.%s.",
		modelName, f.GoPackageName,
		name,
	))
	leadingComments := appendDeprecationSuffix(
		leading,
		m.Desc.Options().(*descriptorpb.MessageOptions).GetDeprecated(),
	)

	g.P(leadingComments,
		"type ", modelName, " struct {")

	// TODO: Continue with fields here.
	// genMessageFields(g, f, m)

	g.P("}")
	g.P()

	// TODO: Continue with APIs here.
	// genConverters(g, f, m)
}

// appendDeprecationSuffix optionally appends a deprecation notice as a suffix.
func appendDeprecationSuffix(prefix protogen.Comments, deprecated bool) protogen.Comments {
	if !deprecated {
		return prefix
	}
	if prefix != "" {
		prefix += "\n"
	}
	return prefix + " Deprecated: Do not use.\n"
}
