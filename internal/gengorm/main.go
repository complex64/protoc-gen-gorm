package gengorm

import (
	"flag"
	"fmt"

	"github.com/complex64/protoc-gen-gorm/internal/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	// Use extension .pb.go, just like `protoc-gen-go` does.
	extension = "_gorm.pb.go"
)

func GenerateFile(fs flag.FlagSet, plugin *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	filename := file.GeneratedFilenamePrefix + extension

	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	f, err := newFileInfo(file)
	if err != nil {
		return nil, err
	}

	genHeader(plugin, g, f)
	g.P("package ", file.GoPackageName)
	g.P()

	for i, imps := 0, f.Desc.Imports(); i < imps.Len(); i++ {
		genImport(plugin, g, f, imps.Get(i))
	}

	for _, message := range f.allMessages {
		genModels(g, f, message)
	}

	return g, nil
}

// genHeader generates the comment header at the top of the file.
// We warn to not edit the file and show the tool versions used to generate the file.
func genHeader(plugin *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo) {
	g.P("// Code generated by protoc-gen-gorm. DO NOT EDIT.")
	g.P("// versions:")

	protocGenGormVersion := version.String()
	protocVersion := "(unknown)"

	if v := plugin.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf(
			"v%v.%v.%v",
			v.GetMajor(),
			v.GetMinor(),
			v.GetPatch(),
		)
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}

	g.P("// \tprotoc-gen-gorm ", protocGenGormVersion)
	g.P("// \tprotoc          ", protocVersion)

	if f.Proto.GetOptions().GetDeprecated() {
		g.P("// ", f.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", f.Desc.Path())
	}

	g.P()
}

// genImport adds necessary import statements to the generated file.
func genImport(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, imp protoreflect.FileImport) {
	if imp.IsPublic {
		panic("TODO: Implement support for public imports")
	}

	impFile, ok := gen.FilesByPath[imp.Path()]
	if !ok {
		return // .proto file unavailable.
	}

	if impFile.GoImportPath == f.GoImportPath {
		return // Same Go package.
	}

	g.Import(impFile.GoImportPath)
	g.P()
}

// genModels generates GORM models and supporting APIs.
func genModels(g *protogen.GeneratedFile, f *fileInfo, m *messageInfo) {
	if !m.genModel {
		return
	}

	name := m.GoIdent.GoName
	modelName := fmt.Sprintf("%sModel", name)

	// Message type declaration.
	g.Annotate(name, m.Location)

	leading := protogen.Comments(fmt.Sprintf(
		" %s is the GORM model for %s.%s.",
		modelName, f.GoPackageName,
		name,
	))
	leadingComments := appendDeprecationSuffix(
		leading,
		m.Desc.Options().(*descriptorpb.MessageOptions).GetDeprecated(),
	)

	g.P(leadingComments,
		"type ", modelName, " struct {")

	// TODO: Continue with fields here.
	// genMessageFields(g, f, m)

	g.P("}")
	g.P()

	// TODO: Continue with APIs here.
	// genConverters(g, f, m)
}

// appendDeprecationSuffix optionally appends a deprecation notice as a suffix.
func appendDeprecationSuffix(prefix protogen.Comments, deprecated bool) protogen.Comments {
	if !deprecated {
		return prefix
	}
	if prefix != "" {
		prefix += "\n"
	}
	return prefix + " Deprecated: Do not use.\n"
}
